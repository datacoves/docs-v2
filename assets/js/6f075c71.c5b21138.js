"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[7928],{22793:(e,a,s)=>{s.d(a,{A:()=>t});const t=s.p+"assets/images/naming_fields-a3dce740e50153451b0fb4f585b95ffb.png"},28453:(e,a,s)=>{s.d(a,{R:()=>r,x:()=>d});var t=s(96540);const n={},i=t.createContext(n);function r(e){const a=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(a):{...a,...e}},[a,e])}function d(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:r(e.components),t.createElement(i.Provider,{value:a},e.children)}},36834:(e,a,s)=>{s.r(a),s.d(a,{assets:()=>o,contentTitle:()=>d,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"best-practices/dbt/object-naming","title":"Object Naming Standards","description":"General Database Relation Naming","source":"@site/docs/best-practices/dbt/object-naming.md","sourceDirName":"best-practices/dbt","slug":"/best-practices/dbt/object-naming","permalink":"/docusaurus-test/docs/best-practices/dbt/object-naming","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Object Naming Standards","sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Dbt guidelines","permalink":"/docusaurus-test/docs/best-practices/dbt/dbt-guidelines"},"next":{"title":"What are Inlets, Bays, and Coves","permalink":"/docusaurus-test/docs/best-practices/dbt/inlets-bays-coves"}}');var n=s(74848),i=s(28453);const r={title:"Object Naming Standards",sidebar_position:2},d="Object naming standards",o={},l=[{value:"General Database Relation Naming",id:"general-database-relation-naming",level:2},{value:"Databases",id:"databases",level:2},{value:"Raw Data",id:"raw-data",level:2},{value:"RAW - Source database",id:"raw---source-database",level:3},{value:"Transformed - Analytics Database",id:"transformed---analytics-database",level:2},{value:"ANALYTICS database",id:"analytics-database",level:3},{value:"ANALYTICS_DEV database",id:"analytics_dev-database",level:3},{value:"ANALYTICS_PR_<code>&lt;pull request #&gt;</code> databases",id:"analytics_pr_pull-request--databases",level:3},{value:"Data Flow",id:"data-flow",level:2},{value:"Raw Database Schemas",id:"raw-database-schemas",level:2},{value:"Raw Database Tables",id:"raw-database-tables",level:3},{value:"Source Connections",id:"source-connections",level:3},{value:"Transformed - Analytics Schemas",id:"transformed---analytics-schemas",level:2},{value:"Inlets",id:"inlets",level:3},{value:"Bays - Schemas",id:"bays---schemas",level:3},{value:"Bays - Tables And Fields",id:"bays---tables-and-fields",level:3},{value:"Coves",id:"coves",level:3}];function c(e){const a={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(a.header,{children:(0,n.jsx)(a.h1,{id:"object-naming-standards",children:"Object naming standards"})}),"\n",(0,n.jsx)(a.h2,{id:"general-database-relation-naming",children:"General Database Relation Naming"}),"\n",(0,n.jsx)(a.p,{children:'As we build database objects for use across multiple areas, naming quickly emerges as the first (and arguably most important) method of documentation. It\'s an area of frustration for many developers, as it requires a context switch from "how do I make this code work" to thinking about future readers and how to make our models discoverable.'}),"\n",(0,n.jsxs)(a.p,{children:["While case sensitive names can be used in some data warehouses like Snowflake, they require double quotes to use and using mixed case introduces potential for duplication (",(0,n.jsx)(a.code,{children:"fieldName"})," and ",(0,n.jsx)(a.code,{children:"FieldName"})," are different objects). We recommend ",(0,n.jsx)(a.code,{children:"snake_case"})," for a consistent structure throughout our Snowflake databases. Similarly, all models managed by dbt must have unique names to allow references to be driven by the name of the table or view."]}),"\n",(0,n.jsxs)(a.p,{children:["As a general rule, names should use full words and increase in granularity left-right: ",(0,n.jsx)(a.code,{children:"patient_address_city"}),". This assists with the sort order of our objects, grouping models and columns into obvious sections."]}),"\n",(0,n.jsx)(a.h2,{id:"databases",children:"Databases"}),"\n",(0,n.jsx)(a.p,{children:"The warehouse should be separated into two primary parts:"}),"\n",(0,n.jsxs)(a.ol,{children:["\n",(0,n.jsxs)(a.li,{children:["The ",(0,n.jsx)(a.strong,{children:"raw"})," database where data gets ingested and which is not exposed to most users."]}),"\n",(0,n.jsxs)(a.li,{children:["The ",(0,n.jsx)(a.strong,{children:"analytics"})," database is where the transformed data exists. This is where dbt operates."]}),"\n"]}),"\n",(0,n.jsx)(a.h2,{id:"raw-data",children:"Raw Data"}),"\n",(0,n.jsx)(a.h3,{id:"raw---source-database",children:"RAW - Source database"}),"\n",(0,n.jsxs)(a.p,{children:["The ",(0,n.jsx)(a.strong,{children:"RAW_PRD"})," database is the landing area for integration tools such as Fivetran and Airbyte. A ",(0,n.jsx)(a.strong,{children:"RAW_DEV"})," database exists in parallel where new sources are added and tested before they are ready to be used in production."]}),"\n",(0,n.jsxs)(a.p,{children:["Sensitive data is restricted at the column level throughout the system: if sensitive data exists, the schema in the ",(0,n.jsx)(a.strong,{children:"raw"})," database is given a suffix of ",(0,n.jsx)(a.code,{children:"_pii"})," to give users a hint that there is sensitive data in this schema. A corresponding security role must be assigned to a dbt developer to be able to see this data."]}),"\n",(0,n.jsxs)(a.p,{children:["Data flattening is managed with dbt in the ",(0,n.jsx)(a.code,{children:"/models/inlets/<source_name>"})," folder of the dbt repository. Flattened models must be created by developers permitted to see the sensitive data. These developers will flatten data to create more useable columns and they will apply masking and row level security rules."]}),"\n",(0,n.jsxs)(a.p,{children:["Developers can add new sources to ",(0,n.jsx)(a.strong,{children:"RAW_DEV"})," using Fivetran or AirByte. Any new data added to the raw database will not be immediately accessible by any user until proper permissions/roles created and granted. Only new and changed tables are created in ",(0,n.jsx)(a.strong,{children:"RAW_DEV"}),". All tables previously released to production will be available via dbt deferral from ",(0,n.jsx)(a.strong,{children:"RAW_PRD"}),"."]}),"\n",(0,n.jsx)(a.h2,{id:"transformed---analytics-database",children:"Transformed - Analytics Database"}),"\n",(0,n.jsx)(a.h3,{id:"analytics-database",children:"ANALYTICS database"}),"\n",(0,n.jsxs)(a.p,{children:["This dbt-managed database contains all transformed models (inlets, bays, and coves) prepared for use by the business. Development and Test environments exist in parallel. ",(0,n.jsx)(a.strong,{children:"analytics_dev"})," is where new models are developed and ",(0,n.jsxs)(a.strong,{children:["analytics_pr_",(0,n.jsx)(a.code,{children:"<pull request #>"})]})," is where the data is checked before changes are released to production."]}),"\n",(0,n.jsxs)(a.p,{children:["Security from ",(0,n.jsx)(a.strong,{children:"RAW_PRD"})," is automatically assigned to any views in the ",(0,n.jsx)(a.strong,{children:"ANALYTICS"})," database; the release process ensures the same rules are applied to any created tables as part of deployment."]}),"\n",(0,n.jsx)(a.h3,{id:"analytics_dev-database",children:"ANALYTICS_DEV database"}),"\n",(0,n.jsx)(a.p,{children:"This database contains individual developer schemas where models are created and modified before they are ready to be deployed to production."}),"\n",(0,n.jsx)(a.p,{children:"All models are created here by developers using dbt within Datacoves. Each developer will have a schema named with their username as defined in the dbt profiles.yml. All models will build into the developer's schema even overriding the custom schema used in production. dbt will only create a models that are added or changed if the deferral feature is used. All developer schemas may be dropped at the start of every week to ensure sensitive data is not retained longer than necessary to comply with GDPR and other regulations."}),"\n",(0,n.jsx)(a.p,{children:'When creating models in Datacoves, any required data may be "deferred" from production: if the upstream models have not been changed, dbt can simply reference them from production rather than rebuilding them and increasing build time and duplication. This ensures that developers are always working on the freshest production data and reduces the likelihood of production failures.'}),"\n",(0,n.jsxs)(a.h3,{id:"analytics_pr_pull-request--databases",children:["ANALYTICS_PR_",(0,n.jsx)(a.code,{children:"<pull request #>"})," databases"]}),"\n",(0,n.jsxs)(a.p,{children:["Every time a pull request is opened from a feature branch to a release branch or from a feature / release branch to the main branch, a new database is automatically created to run and test the changes in that branch. By leveraging dbt's deferral and Slim CI (",(0,n.jsx)(a.code,{children:"state:modified"}),") features, we only build changed models and their downstream dependencies. Deferral allows us to pull unchanged upstream models from production."]}),"\n",(0,n.jsx)(a.p,{children:'These databases are used for UAT as needed and act as "pre-release" for any manual review required to trust the new codebase before it is merged to the main branch.'}),"\n",(0,n.jsx)(a.p,{children:(0,n.jsx)(a.img,{alt:"naming_databases",src:s(56154).A+"",width:"720",height:"405"})}),"\n",(0,n.jsx)(a.h2,{id:"data-flow",children:"Data Flow"}),"\n",(0,n.jsx)(a.p,{children:"The general flow of data is from Raw schemas to Inlets then Bays, and finally Coves. These will be described in more detail below."}),"\n",(0,n.jsx)(a.admonition,{type:"note",children:(0,n.jsxs)(a.p,{children:["See ",(0,n.jsx)(a.a,{href:"./inlets-bays-coves",children:"this page"})," to learn more about Inlets, Bays, and Coves"]})}),"\n",(0,n.jsx)(a.p,{children:(0,n.jsx)(a.img,{alt:"inlets-bays-coves",src:s(55765).A+"",width:"720",height:"405"})}),"\n",(0,n.jsx)(a.h2,{id:"raw-database-schemas",children:"Raw Database Schemas"}),"\n",(0,n.jsxs)(a.p,{children:["The ",(0,n.jsx)(a.strong,{children:"RAW_PRD"})," database is primarily populated directly from vendor / source system data, and exists as a mirror in place of direct connection to those sources. Schemas are named as follows: ",(0,n.jsx)(a.code,{children:"<system/vendor name>_<dataset name>"}),". This can be configured in Fivetran / AirByte (Airbyte calls schemas Namespaces). Source tables keep the name given by the source system. In large implementations where a source is unique to a specific country, the schema should be named as follows: ",(0,n.jsx)(a.code,{children:"<country_code>_<system/vendor name>_<dataset name>"})," for clarity."]}),"\n",(0,n.jsx)(a.h3,{id:"raw-database-tables",children:"Raw Database Tables"}),"\n",(0,n.jsxs)(a.p,{children:["To account for schema drift, all data should be loaded into VARIANT (semi-structured) columns directly in the database. You should create additional tables for nested objects as follows: ",(0,n.jsx)(a.code,{children:"<schema name>_<source table name>[_<nested object key>]"})," with columns matching the keys of the original source."]}),"\n",(0,n.jsx)(a.p,{children:"Schema name is included in order to avoid duplication where multiple source systems include identically-named tables ('User', 'Customer', etc). By keeping this source-driven convention, these can be created quickly by a technical team without needing to understand the subject matter."}),"\n",(0,n.jsx)(a.h3,{id:"source-connections",children:"Source Connections"}),"\n",(0,n.jsx)(a.p,{children:"A source connection configuration should be given the name of the source itself allowing clear visibility of where the data comes from without the need to open a connection configuration screen."}),"\n",(0,n.jsx)(a.h2,{id:"transformed---analytics-schemas",children:"Transformed - Analytics Schemas"}),"\n",(0,n.jsx)(a.p,{children:(0,n.jsx)(a.img,{alt:"naming_schemas",src:s(61096).A+"",width:"720",height:"405"})}),"\n",(0,n.jsx)(a.h3,{id:"inlets",children:"Inlets"}),"\n",(0,n.jsx)(a.p,{children:"Inlet Schema names should match those in the RAW database for traceability."}),"\n",(0,n.jsx)(a.p,{children:"The first step in making raw data usable is to flatten and do some basic cleanup of the data. In dbt we use the inlets folder and we mirror the schema name created in the raw database."}),"\n",(0,n.jsx)(a.p,{children:"Here we do some basic transformation including:"}),"\n",(0,n.jsxs)(a.ul,{children:["\n",(0,n.jsx)(a.li,{children:"flattening"}),"\n",(0,n.jsx)(a.li,{children:"aliasing columns for clarity"}),"\n",(0,n.jsx)(a.li,{children:"casting"}),"\n",(0,n.jsx)(a.li,{children:"cleansing (like converting all time stamps to UTC)"}),"\n"]}),"\n",(0,n.jsx)(a.h3,{id:"bays---schemas",children:"Bays - Schemas"}),"\n",(0,n.jsx)(a.p,{children:"The Bay schemas in the ANALYTICS database are named for data domains / entities of the business. These are intended for reuse in many areas. They are developed by cross-functional teams responsible for their ongoing development, so time should be taken to understand the subject and potential use cases."}),"\n",(0,n.jsx)(a.p,{children:'As the primary developers are still technical, there will be a natural leaning toward system-centric names - this should be challenged in code review, as this is our main chance to translate data from what a vendor cares about ("User") to what we actually care about ("Employee", "Customer", "Events").'}),"\n",(0,n.jsx)(a.p,{children:"Names should be:"}),"\n",(0,n.jsxs)(a.ol,{children:["\n",(0,n.jsx)(a.li,{children:"verbose"}),"\n",(0,n.jsx)(a.li,{children:"generally increase in complexity left-right"}),"\n",(0,n.jsx)(a.li,{children:"un-repeating within a database \u2192 schema \u2192 model \u2192 column structure where practical"}),"\n"]}),"\n",(0,n.jsxs)(a.p,{children:["The primary goal is searchability; while the structure in ",(0,n.jsx)(a.code,{children:"_analytics.bay_customer.dim_customer.first_name_"})," breaks principles 2 and 3, renaming the dimension (",(0,n.jsx)(a.code,{children:"dim_customer"}),") or column (",(0,n.jsx)(a.code,{children:"name_first"}),") would make it harder to find and understand."]}),"\n",(0,n.jsx)(a.h3,{id:"bays---tables-and-fields",children:"Bays - Tables And Fields"}),"\n",(0,n.jsxs)(a.p,{children:["All models in a Bay schema should describe their modelling style as the first segment of the name: ",(0,n.jsx)(a.code,{children:"dim_"}),", ",(0,n.jsx)(a.code,{children:"fct_"}),", ",(0,n.jsx)(a.code,{children:"ref_"})," etc."]}),"\n",(0,n.jsxs)(a.p,{children:["If any aggregation is required in a bay, this should be a suffix (",(0,n.jsx)(a.code,{children:"fct_direct_sales_month"}),") to group alongside other ",(0,n.jsx)(a.code,{children:"direct_sales"})," facts. This immediately prepares the Cove developer (who are also technically skilled) with understanding of the join types they will need to query the object."]}),"\n",(0,n.jsxs)(a.p,{children:["Any ephemeral or staging models which aren't intended for use outside the Bay should be prefixed ",(0,n.jsx)(a.code,{children:"int_"})," to show their intermediate/internal nature."]}),"\n",(0,n.jsxs)(a.p,{children:["Any static CSV data seeded from the dbt repository can be loaded directly to the appropriate name (e.g. ",(0,n.jsx)(a.code,{children:"dim_date"}),")."]}),"\n",(0,n.jsx)(a.h3,{id:"coves",children:"Coves"}),"\n",(0,n.jsxs)(a.p,{children:["The Cove schemas in ",(0,n.jsx)(a.strong,{children:"ANALYTICS"})," are named for specific use cases and analytic areas. These are built with less focus on reuse and a much greater focus on the experience for the user that will be consuming the data."]}),"\n",(0,n.jsxs)(a.p,{children:["All naming in a cove should be focused on use by less technically skilled users and tools, especially if the data is intended for self service. In many visualization tools it's easy to confuse ",(0,n.jsx)(a.code,{children:"patients.name"})," with ",(0,n.jsx)(a.code,{children:"products.name"}),", so we must include the table name as ",(0,n.jsx)(a.code,{children:"patients.patient_name"})," in models."]}),"\n",(0,n.jsx)(a.p,{children:(0,n.jsx)(a.img,{alt:"naming_fields",src:s(22793).A+"",width:"2452",height:"294"})}),"\n",(0,n.jsx)(a.p,{children:(0,n.jsx)(a.img,{alt:"naming_fields2",src:s(40639).A+"",width:"1828",height:"306"})}),"\n",(0,n.jsxs)(a.p,{children:["Where a modelling methodology has been used, prefixes should be used to describe models: ",(0,n.jsx)(a.code,{children:"dim_"}),", ",(0,n.jsx)(a.code,{children:"fct_"}),", etc."]}),"\n",(0,n.jsxs)(a.p,{children:["Any single-table analyses should be prefixed ",(0,n.jsx)(a.code,{children:"mart_"})," and any models not intended for ongoing use should be prefixed ",(0,n.jsx)(a.code,{children:"temp_"}),"."]}),"\n",(0,n.jsxs)(a.p,{children:["End users may create their own models in their respective cove. These models should be prefixed with the username of the person who created them if not intended for general use: ",(0,n.jsx)(a.code,{children:"<username>_"}),"."]}),"\n",(0,n.jsxs)(a.p,{children:["Any aggregation should be described in a suffix on the model/column: ",(0,n.jsx)(a.code,{children:"customer_countries.customer_count"}),"."]})]})}function h(e={}){const{wrapper:a}={...(0,i.R)(),...e.components};return a?(0,n.jsx)(a,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},40639:(e,a,s)=>{s.d(a,{A:()=>t});const t=s.p+"assets/images/naming_fields2-06078aeb4fa32e0e4276fe719948e772.png"},55765:(e,a,s)=>{s.d(a,{A:()=>t});const t=s.p+"assets/images/inlets-bays-coves-135e24ada85e0be4daa037000186cd2c.png"},56154:(e,a,s)=>{s.d(a,{A:()=>t});const t=s.p+"assets/images/naming_databases-032d78b46728e155c7b088ce6ac7e9fb.png"},61096:(e,a,s)=>{s.d(a,{A:()=>t});const t=s.p+"assets/images/naming_schemas-4f5a7baa7d85649394af91dcdb4d4c9f.png"}}]);